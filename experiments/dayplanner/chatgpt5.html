<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Day Planner</title>
  <style>
    :root{
      --bg:#0b0c10;
      --text:#e9edf1;
      --muted:#9aa4af;
      --accent:#7aa2ff;
      --accent2:#7dffb2;
      --danger:#ff6b6b;
      --shadow: 0 8px 26px rgba(0,0,0,.35);
      --radius: 14px;

      --timelineW: 68px;
      --dayHeight: 1440px; /* 1px per minute */
      --snap: 5;           /* minutes snap */

      --colGap: 10px;
      --pomoTrackW: 16px;
    }

    * { box-sizing:border-box; }
    body{
      margin:0;
      background:linear-gradient(180deg, var(--bg), #07080b);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      letter-spacing: .2px;
    }

    .wrap{
      max-width: 1320px;
      margin: 18px auto 36px;
      padding: 0 14px;
    }

    .topbar{
      display:flex;
      gap:12px;
      align-items:flex-start;
      justify-content:space-between;
      margin-bottom: 10px;
      flex-wrap:wrap;
    }

    .title{
      display:flex;
      flex-direction:column;
      gap:2px;
      min-width: 360px;
    }
    .title h1{
      margin:0;
      font-size: 16px;
      font-weight: 750;
    }
    .title .hint{
      color: var(--muted);
      font-size: 12px;
      line-height: 1.25;
      max-width: 820px;
    }

    .controls{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    .btn, .input{
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.10);
      color: var(--text);
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 12px;
      outline:none;
    }
    .btn{
      cursor:pointer;
      user-select:none;
      transition: transform .05s ease, border-color .2s ease, background .2s ease;
    }
    .btn:hover{
      border-color: rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.05);
    }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      border-color: rgba(122,162,255,0.5);
      background: rgba(122,162,255,0.10);
    }
    .btn.danger{
      border-color: rgba(255,107,107,0.5);
      background: rgba(255,107,107,0.10);
    }

    /* Minimal single-line Pomodoro */
    .pomoLine{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
      box-shadow: var(--shadow);
      margin-bottom: 12px;
    }
    .pomoLine.work{
      background: rgba(122,162,255,0.10);
      border-color: rgba(122,162,255,0.22);
    }
    .pomoLine.break{
      background: rgba(125,255,178,0.08);
      border-color: rgba(125,255,178,0.18);
    }
    .pomoLine .mono{
      font-variant-numeric: tabular-nums;
    }
    .pomoLine small{ color: var(--muted); }
    .pomoLine .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.12);
      font-size: 12px;
    }
    .pomoLine .pill input{
      padding: 5px 7px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
      color: var(--text);
      width: 58px;
      font-size: 12px;
      outline:none;
    }
    .pomoLine .tinyBtn{
      padding: 5px 9px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
      color: var(--text);
      font-size: 12px;
      cursor:pointer;
    }
    .pomoLine .tinyBtn:hover{
      border-color: rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.05);
    }
    .pomoLine .tinyBtn.primary{
      border-color: rgba(122,162,255,0.5);
      background: rgba(122,162,255,0.10);
    }
    .pomoLine .tinyBtn.danger{
      border-color: rgba(255,107,107,0.5);
      background: rgba(255,107,107,0.10);
    }

    /* Header row now includes pomo tracks */
    .headerRow{
      margin-top: 6px;
      margin-bottom: 10px;
      display:grid;
      grid-template-columns: var(--timelineW) 1fr 1fr 1fr var(--pomoTrackW) var(--pomoTrackW);
      gap:var(--colGap);
      align-items:center;
    }

    .colTitle{
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: var(--radius);
      padding: 10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      box-shadow: var(--shadow);
      min-height: 42px;
    }
    .colTitle b{
      font-size: 12px;
      letter-spacing: .6px;
      text-transform: uppercase;
    }
    .colTitle span{
      color: var(--muted);
      font-size: 12px;
    }
    .spacer{ height:1px; }

    .tinyTitle{
      height: 42px;
      border-radius: var(--radius);
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.02);
      box-shadow: var(--shadow);
      display:flex;
      align-items:center;
      justify-content:center;
      color: rgba(233,237,241,0.7);
      font-size: 11px;
      letter-spacing: .4px;
      text-transform: uppercase;
    }

    .row{
      display:grid;
      grid-template-columns: var(--timelineW) 1fr 1fr 1fr var(--pomoTrackW) var(--pomoTrackW);
      gap: var(--colGap);
      align-items:stretch;
    }

    .timeline{
      position: relative;
      height: var(--dayHeight);
      border-radius: var(--radius);
      background: transparent;
      overflow:hidden;
    }
    .timeline .tick{
      position:absolute;
      left:0;
      width: 100%;
      transform: translateY(-0.5px);
      color: var(--muted);
      font-size: 11px;
      padding-left: 6px;
      display:flex;
      align-items:center;
      gap:6px;
      pointer-events:none;
      opacity:.9;
    }
    .timeline .tick .line{
      height:1px;
      flex:1;
      background: transparent;
    }

    .col{
      position: relative;
      height: var(--dayHeight);
      border-radius: var(--radius);
      background:
        linear-gradient(to bottom, rgba(255,255,255,0.02), rgba(255,255,255,0.01)),
        repeating-linear-gradient(to bottom, transparent 0px, transparent 29px, rgba(255,255,255,0.05) 30px);
      border: 1px solid rgba(255,255,255,0.08);
      overflow:hidden;
      box-shadow: var(--shadow);
    }
    .col::before{
      content:"";
      position:absolute; inset:0;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,0.04) 0px,
        rgba(255,255,255,0.04) 1px,
        transparent 1px,
        transparent 60px
      );
      pointer-events:none;
      opacity:.35;
    }

    .track{
      position: relative;
      height: var(--dayHeight);
      border-radius: var(--radius);
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.02);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .track::before{
      content:"";
      position:absolute; inset:0;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,0.04) 0px,
        rgba(255,255,255,0.04) 1px,
        transparent 1px,
        transparent 60px
      );
      pointer-events:none;
      opacity:.20;
    }

    .nowLine{
      position:absolute;
      left:0;
      right:0;
      height:1px;
      background: rgba(122,162,255,0.8);
      box-shadow: 0 0 0 2px rgba(122,162,255,0.12);
      pointer-events:none;
      z-index:5;
    }

    /* Block with always-visible time strip on the left */
    .block{
      position:absolute;
      left: 10px;
      right: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(122,162,255,0.18);
      backdrop-filter: blur(6px);
      cursor: grab;
      user-select:none;
      overflow:hidden;
      min-height: 16px;
      z-index: 10;
      padding: 0;
      display:flex;
      align-items:stretch;
    }
    .block.actual{
      background: rgba(125,255,178,0.14);
      border-color: rgba(125,255,178,0.28);
    }
    .block.scratch{
      background: rgba(255,255,255,0.06);
      border-color: rgba(255,255,255,0.16);
    }

    .timeStrip{
      width: 78px;
      border-right: 1px solid rgba(255,255,255,0.12);
      padding: 8px 8px;
      font-size: 11px;
      color: rgba(233,237,241,0.90);
      display:flex;
      flex-direction:column;
      justify-content:space-between;
      font-variant-numeric: tabular-nums;
      background: rgba(0,0,0,0.10);
      flex-shrink:0;
    }
    .timeStrip .dur{
      color: rgba(233,237,241,0.70);
      font-size: 11px;
    }

    .blockBody{
      flex:1;
      padding: 8px 10px;
      min-width: 0;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }

    .label{
      font-size: 12px;
      font-weight: 650;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      outline:none;
      padding: 2px 0;
      user-select:text;
      cursor:text;
      min-height: 18px;
    }
    .label:focus{
      white-space:normal;
      text-overflow:clip;
    }

    .miniBtnRow{
      display:flex;
      gap:6px;
      align-items:center;
      opacity: 0;
      transition: opacity .15s ease;
      flex-shrink:0;
    }
    .block:hover .miniBtnRow{ opacity: 1; }

    /* Smaller, subtle delete */
    .miniDel{
      width: 18px;
      height: 18px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.10);
      color: rgba(233,237,241,0.75);
      cursor:pointer;
      font-size: 12px;
      line-height: 1;
      padding:0;
    }
    .miniDel:hover{
      border-color: rgba(255,107,107,0.35);
      background: rgba(255,107,107,0.10);
      color: rgba(233,237,241,0.95);
    }

    .resizeHandle{
      position:absolute;
      left: 0;
      right: 0;
      height: 10px;
      cursor: ns-resize;
      opacity:.7;
      z-index: 40;
    }
    .resizeHandle.top{ top: -2px; }
    .resizeHandle.bottom{ bottom: -2px; }

    /* Pomodoro blocks (red) in their own tracks */
    .pomoBlock{
      position:absolute;
      left: 3px;
      right: 3px;
      border-radius: 7px;
      border: 1px solid rgba(255,107,107,0.55);
      background: rgba(255,107,107,0.22);
      min-height: 10px;
      z-index: 25;
      pointer-events:none;
    }
    .pomoBlock.break{
      border-color: rgba(255,107,107,0.40);
      background: rgba(255,107,107,0.14);
      opacity: .85;
    }

    .footer{
      margin-top: 12px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }

    /* Print */
    @media print{
      body{ background:#fff; color:#000; }
      .wrap{ max-width:none; margin:0; padding:0; }
      .topbar, .pomoLine, .footer{ display:none !important; }

      .colTitle, .tinyTitle{
        box-shadow:none;
        background:#fff;
        border: 1px solid #bbb;
        border-radius: 0;
      }
      .col, .track{
        box-shadow:none;
        border-radius: 0;
        border: 1px solid #bbb;
        background: #fff;
      }
      .timeline{ border-radius:0; }
      .block{
        box-shadow:none;
        background: #eaefff;
        border: 1px solid #778;
      }
      .block.actual{
        background: #e9fff1;
        border: 1px solid #585;
      }
      .block.scratch{
        background: #f4f4f4;
        border: 1px solid #999;
      }
      .pomoBlock{ display:none !important; }
      .nowLine{ display:none !important; }
      .miniBtnRow{ display:none !important; }
      .row, .headerRow{ gap:6px; }
      @page { margin: 10mm; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="title">
        <h1 id="pageTitle">Day Planner</h1>
        <div class="hint">Drag to draw blocks. Drag blocks to move. Resize from edges. Double-click a Plan block to copy it to Actual.</div>
      </div>
      <div class="controls">
        <input class="input" id="date" type="date" />
        <button class="btn" id="today">Today</button>
        <button class="btn danger" id="clear">Clear</button>
        <button class="btn primary" id="print">Print / Save as PDF</button>
      </div>
    </div>

    <!-- Pomodoro: single line; background indicates Work/Break -->
    <div class="pomoLine" id="pomoLine">
      <b>Pomodoro</b>
      <span class="mono" id="pomoStatus">Idle</span>
      <span class="mono" id="pomoLeft">—</span>

      <span class="pill">
        <small>W</small>
        <input id="workMin" type="number" min="1" value="25" />
        <small>min</small>
      </span>
      <span class="pill">
        <small>B</small>
        <input id="breakMin" type="number" min="1" value="5" />
        <small>min</small>
      </span>

      <button class="tinyBtn" id="notify">Notify</button>
      <button class="tinyBtn primary" id="startWork">Work</button>
      <button class="tinyBtn" id="startBreak">Break</button>
      <button class="tinyBtn" id="pause">Pause</button>
      <button class="tinyBtn danger" id="stop">Stop</button>

      <div style="flex:1"></div>
      <small>Ends wait for your next click.</small>
    </div>

    <div class="headerRow">
      <div class="spacer"></div>
      <div class="colTitle"><b>Plan</b><span id="planSummary">—</span></div>
      <div class="colTitle"><b>Actual</b><span id="actualSummary">—</span></div>
      <div class="colTitle"><b>Scratch</b><span id="scratchSummary">—</span></div>
      <div class="tinyTitle">P</div>
      <div class="tinyTitle">B</div>
    </div>

    <div class="row">
      <div class="timeline" id="timeline"></div>
      <div class="col" id="planCol" data-kind="plan"></div>
      <div class="col" id="actualCol" data-kind="actual"></div>
      <div class="col" id="scratchCol" data-kind="scratch"></div>
      <div class="track" id="pomoWorkTrack"></div>
      <div class="track" id="pomoBreakTrack"></div>
    </div>

    <div class="footer">
      Printing: use your browser’s print dialog (Ctrl/Cmd+P) and choose “Save as PDF” if you want a PDF file.
    </div>
  </div>

  <script>
    (() => {
      const DAY_MIN = 24 * 60;
      const dayHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--dayHeight'), 10);
      const snapMin = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--snap'), 10);
      const pxPerMin = dayHeight / DAY_MIN;

      const pageTitle = document.getElementById('pageTitle');
      const timeline = document.getElementById('timeline');
      const dateInput = document.getElementById('date');

      const planCol = document.getElementById('planCol');
      const actualCol = document.getElementById('actualCol');
      const scratchCol = document.getElementById('scratchCol');

      const pomoWorkTrack = document.getElementById('pomoWorkTrack');
      const pomoBreakTrack = document.getElementById('pomoBreakTrack');

      const planSummary = document.getElementById('planSummary');
      const actualSummary = document.getElementById('actualSummary');
      const scratchSummary = document.getElementById('scratchSummary');

      // Pomodoro UI
      const pomoLine = document.getElementById('pomoLine');
      const pomoStatus = document.getElementById('pomoStatus');
      const pomoLeftEl = document.getElementById('pomoLeft');
      const workMinEl = document.getElementById('workMin');
      const breakMinEl = document.getElementById('breakMin');

      let state = { plan: [], actual: [], scratch: [] };

      function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
      function snap(min){ return Math.round(min / snapMin) * snapMin; }
      function yToMin(y){ return clamp(Math.round(y / pxPerMin), 0, DAY_MIN); }
      function minToY(min){ return min * pxPerMin; }
      function pad2(n){ return String(n).padStart(2,'0'); }
      function fmtTime(min){
        const h = Math.floor(min / 60);
        const m = min % 60;
        return `${pad2(h)}:${pad2(m)}`;
      }
      function fmtDur(min){
        const h = Math.floor(min / 60);
        const m = min % 60;
        if(h === 0) return `${m}m`;
        if(m === 0) return `${h}h`;
        return `${h}h ${m}m`;
      }
      function storageKey(dateStr){ return `daytool:v4:${dateStr}`; }
      function newId(){ return Math.random().toString(16).slice(2) + Date.now().toString(16); }

      function setTitleForDate(dateStr){
        // dateStr is YYYY-MM-DD
        const d = new Date(dateStr + "T00:00:00");
        const weekday = d.toLocaleDateString(undefined, { weekday: 'long' });
        const pretty = d.toLocaleDateString(undefined, { year:'numeric', month:'short', day:'numeric' });
        pageTitle.textContent = `Day Planner — ${weekday}, ${pretty}`;
        document.title = `Day Planner — ${weekday}, ${pretty}`;
      }

      function sumDur(list){
        let total = 0;
        for(const b of list) total += Math.max(0, (b.end - b.start));
        return total;
      }
      function updateSummaries(){
        planSummary.textContent = fmtDur(sumDur(state.plan));
        actualSummary.textContent = fmtDur(sumDur(state.actual));
        scratchSummary.textContent = fmtDur(sumDur(state.scratch));
      }

      function save(){
        localStorage.setItem(storageKey(dateInput.value), JSON.stringify(state));
        updateSummaries();
      }
      function load(){
        setTitleForDate(dateInput.value);
        const raw = localStorage.getItem(storageKey(dateInput.value));
        if(!raw){
          state = { plan: [], actual: [], scratch: [] };
          render();
          return;
        }
        try{
          const parsed = JSON.parse(raw);
          state = {
            plan: Array.isArray(parsed.plan) ? parsed.plan : [],
            actual: Array.isArray(parsed.actual) ? parsed.actual : [],
            scratch: Array.isArray(parsed.scratch) ? parsed.scratch : []
          };
        }catch{
          state = { plan: [], actual: [], scratch: [] };
        }
        render();
      }

      function sortKind(kind){
        state[kind].sort((a,b) => a.start - b.start);
      }

      function buildTimeline(){
        timeline.innerHTML = '';
        for(let h = 0; h <= 24; h++){
          const y = minToY(h * 60);
          const tick = document.createElement('div');
          tick.className = 'tick';
          tick.style.top = `${y}px`;
          const label = (h === 24) ? '24:00' : `${pad2(h)}:00`;
          tick.innerHTML = `<div style="width:52px">${label}</div><div class="line"></div>`;
          timeline.appendChild(tick);
        }
      }

      // Now lines
      const nowLinePlan = document.createElement('div'); nowLinePlan.className = 'nowLine';
      const nowLineActual = document.createElement('div'); nowLineActual.className = 'nowLine';
      const nowLineScratch = document.createElement('div'); nowLineScratch.className = 'nowLine';
      const nowLineWork = document.createElement('div'); nowLineWork.className = 'nowLine';
      const nowLineBreak = document.createElement('div'); nowLineBreak.className = 'nowLine';
      planCol.appendChild(nowLinePlan);
      actualCol.appendChild(nowLineActual);
      scratchCol.appendChild(nowLineScratch);
      pomoWorkTrack.appendChild(nowLineWork);
      pomoBreakTrack.appendChild(nowLineBreak);

      function updateNowLine(){
        const d = new Date();
        const todayStr = d.toISOString().slice(0,10);
        const show = (dateInput.value === todayStr);
        const min = d.getHours() * 60 + d.getMinutes();
        const top = `${minToY(min)}px`;

        for(const line of [nowLinePlan, nowLineActual, nowLineScratch, nowLineWork, nowLineBreak]){
          line.style.display = show ? 'block' : 'none';
          if(show) line.style.top = top;
        }
      }

      function createBlock(kind, start, end, label=''){
        const s = clamp(snap(start), 0, DAY_MIN);
        const e = clamp(snap(end), 0, DAY_MIN);
        if(Math.abs(e - s) < snapMin) return null;
        const b = { id: newId(), start: Math.min(s,e), end: Math.max(s,e), label };
        state[kind].push(b);
        sortKind(kind);
        save();
        render();
        return b;
      }

      function removeBlock(kind, id){
        state[kind] = state[kind].filter(b => b.id !== id);
        save();
        render();
      }

      function render(){
        for(const col of [planCol, actualCol, scratchCol]){
          [...col.querySelectorAll('.block')].forEach(n => n.remove());
        }
        for(const b of state.plan) createBlockEl(planCol, b, 'plan');
        for(const b of state.actual) createBlockEl(actualCol, b, 'actual');
        for(const b of state.scratch) createBlockEl(scratchCol, b, 'scratch');

        updateSummaries();
        updateNowLine();
        renderPomodoroTracks();
      }

      function updateBlock(kind, id, patch, {rerender=false} = {}){
        const b = state[kind].find(x => x.id === id);
        if(!b) return;
        Object.assign(b, patch);
        b.start = clamp(snap(b.start), 0, DAY_MIN);
        b.end = clamp(snap(b.end), 0, DAY_MIN);
        if(b.end < b.start) [b.start, b.end] = [b.end, b.start];
        if(b.end - b.start < snapMin) b.end = clamp(b.start + snapMin, 0, DAY_MIN);
        sortKind(kind);
        save();
        if(rerender) render();
      }

      function kindClass(kind){
        if(kind === 'actual') return 'actual';
        if(kind === 'scratch') return 'scratch';
        return '';
      }

      function focusLabel(labelEl){
        labelEl.focus();
        const range = document.createRange();
        range.selectNodeContents(labelEl);
        range.collapse(false);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      }

      function createBlockEl(col, b, kind){
        const el = document.createElement('div');
        el.className = `block ${kindClass(kind)}`.trim();
        el.dataset.id = b.id;

        const top = minToY(b.start);
        const height = Math.max(16, minToY(b.end) - minToY(b.start));
        el.style.top = `${top}px`;
        el.style.height = `${height}px`;

        el.innerHTML = `
          <div class="resizeHandle top" data-handle="top"></div>
          <div class="resizeHandle bottom" data-handle="bottom"></div>
          <div class="timeStrip">
            <div class="range"></div>
            <div class="dur"></div>
          </div>
          <div class="blockBody">
            <div class="label" contenteditable="true" spellcheck="false"></div>
            <div class="miniBtnRow">
              <button class="miniDel" title="Delete">×</button>
            </div>
          </div>
        `;

        const labelEl = el.querySelector('.label');
        labelEl.textContent = b.label || '';
        const rangeEl = el.querySelector('.range');
        const durEl = el.querySelector('.dur');

        const syncTime = () => {
          rangeEl.textContent = `${fmtTime(b.start)}–${fmtTime(b.end)}`;
          durEl.textContent = `${fmtDur(b.end - b.start)}`;
        };
        syncTime();

        // Inline edit commit
        labelEl.addEventListener('keydown', (ev) => {
          if(ev.key === 'Enter'){
            ev.preventDefault();
            labelEl.blur();
          }
        });
        labelEl.addEventListener('blur', () => {
          const txt = (labelEl.textContent || '').trim();
          updateBlock(kind, b.id, { label: txt }, { rerender:false });
        });

        // Delete
        el.querySelector('.miniDel').addEventListener('click', (ev) => {
          ev.stopPropagation();
          removeBlock(kind, b.id);
        });

        // Double-click Plan => copy to Actual
        if(kind === 'plan'){
          el.addEventListener('dblclick', (ev) => {
            // ignore dblclicks on label (editing) or delete
            if(ev.target.closest('button')) return;
            if(ev.target.closest('[contenteditable="true"]')) return;

            // Create a copy in actual with same time + label
            state.actual.push({
              id: newId(),
              start: b.start,
              end: b.end,
              label: b.label || ''
            });
            sortKind('actual');
            save();
            render();

            // flash? (tiny, optional) - keep simple.
          });
        }

        // Drag/resize (don't drag while editing)
        el.addEventListener('pointerdown', (ev) => {
          if(ev.target.closest('[contenteditable="true"]')) return;
          const handle = ev.target.closest('.resizeHandle');
          if(handle){
            startResize(ev, col, kind, b.id, handle.dataset.handle, syncTime, el);
            return;
          }
          if(ev.target.closest('button')) return;
          startMove(ev, col, kind, b.id, syncTime, el);
        });

        // Click empty blockBody to focus label
        el.querySelector('.blockBody').addEventListener('click', (ev) => {
          if(ev.target.closest('button')) return;
          if(!ev.target.closest('.label')) focusLabel(labelEl);
        });

        col.appendChild(el);
      }

      // Drawing blocks on empty space + auto-focus label
      function attachDraw(col){
        let drawing = null;

        col.addEventListener('pointerdown', (ev) => {
          if(ev.target.closest('.block')) return;

          col.setPointerCapture(ev.pointerId);
          const kind = col.dataset.kind;
          const rect = col.getBoundingClientRect();
          const y0 = clamp(ev.clientY - rect.top, 0, dayHeight);
          const startMin = snap(yToMin(y0));
          drawing = { kind, startMin, currentMin: startMin };

          const temp = document.createElement('div');
          temp.className = `block ${kindClass(kind)}`.trim();
          temp.style.left = '10px';
          temp.style.right = '10px';
          temp.style.top = `${minToY(startMin)}px`;
          temp.style.height = `${Math.max(16, minToY(startMin + snapMin) - minToY(startMin))}px`;
          temp.style.opacity = '0.85';
          temp.style.cursor = 'crosshair';
          temp.innerHTML = `
            <div class="timeStrip">
              <div class="range">${fmtTime(startMin)}–${fmtTime(startMin)}</div>
              <div class="dur">drawing</div>
            </div>
            <div class="blockBody">
              <div class="label" style="opacity:.65">…</div>
            </div>
          `;
          col.appendChild(temp);
          drawing.temp = temp;

          ev.preventDefault();
        });

        col.addEventListener('pointermove', (ev) => {
          if(!drawing) return;
          const rect = col.getBoundingClientRect();
          const y = clamp(ev.clientY - rect.top, 0, dayHeight);
          const m = snap(yToMin(y));
          drawing.currentMin = m;

          const a = Math.min(drawing.startMin, drawing.currentMin);
          const b = Math.max(drawing.startMin, drawing.currentMin);
          const top = minToY(a);
          const height = Math.max(16, minToY(b) - minToY(a));
          drawing.temp.style.top = `${top}px`;
          drawing.temp.style.height = `${height}px`;
          drawing.temp.querySelector('.range').textContent = `${fmtTime(a)}–${fmtTime(b)}`;
          drawing.temp.querySelector('.dur').textContent = `${fmtDur(b-a)}`;
        });

        col.addEventListener('pointerup', () => {
          if(!drawing) return;
          const kind = drawing.kind;
          const a = Math.min(drawing.startMin, drawing.currentMin);
          const b = Math.max(drawing.startMin, drawing.currentMin);
          drawing.temp.remove();
          drawing = null;

          const created = createBlock(kind, a, b, '');
          if(!created) return;

          requestAnimationFrame(() => {
            const targetCol = document.querySelector(`.col[data-kind="${kind}"]`);
            const el = targetCol && targetCol.querySelector(`.block[data-id="${CSS.escape(created.id)}"]`);
            const labelEl = el && el.querySelector('.label');
            if(labelEl) focusLabel(labelEl);
          });
        });
      }

      // Move blocks: smooth DOM updates then commit on release
      function startMove(ev, col, kind, id, syncTime, el){
        el.style.cursor = 'grabbing';
        el.setPointerCapture(ev.pointerId);

        const rect = col.getBoundingClientRect();
        const pointerStartY = clamp(ev.clientY - rect.top, 0, dayHeight);

        const b = state[kind].find(x => x.id === id);
        const dur = b.end - b.start;
        const origStart = b.start;

        function onMove(e){
          const y = clamp(e.clientY - rect.top, 0, dayHeight);
          const deltaPx = y - pointerStartY;
          const deltaMin = deltaPx / pxPerMin;
          let newStart = snap(origStart + deltaMin);
          newStart = clamp(newStart, 0, DAY_MIN - dur);

          b.start = newStart;
          b.end = newStart + dur;

          el.style.top = `${minToY(b.start)}px`;
          syncTime();
        }

        function onUp(){
          el.style.cursor = 'grab';
          window.removeEventListener('pointermove', onMove);
          window.removeEventListener('pointerup', onUp);
          sortKind(kind);
          save();
          render();
        }

        window.addEventListener('pointermove', onMove);
        window.addEventListener('pointerup', onUp);
      }

      function startResize(ev, col, kind, id, which, syncTime, el){
        el.setPointerCapture(ev.pointerId);

        const rect = col.getBoundingClientRect();
        const b = state[kind].find(x => x.id === id);
        const origStart = b.start;
        const origEnd = b.end;

        function onMove(e){
          const y = clamp(e.clientY - rect.top, 0, dayHeight);
          const m = snap(yToMin(y));

          if(which === 'top'){
            b.start = clamp(m, 0, origEnd - snapMin);
            b.end = origEnd;
          }else{
            b.start = origStart;
            b.end = clamp(m, origStart + snapMin, DAY_MIN);
          }

          el.style.top = `${minToY(b.start)}px`;
          el.style.height = `${Math.max(16, minToY(b.end) - minToY(b.start))}px`;
          syncTime();
        }

        function onUp(){
          window.removeEventListener('pointermove', onMove);
          window.removeEventListener('pointerup', onUp);
          updateBlock(kind, id, { start: b.start, end: b.end }, { rerender:true });
        }

        window.addEventListener('pointermove', onMove);
        window.addEventListener('pointerup', onUp);
        ev.preventDefault();
      }

      // Buttons
      document.getElementById('print').addEventListener('click', () => window.print());
      document.getElementById('clear').addEventListener('click', () => {
        if(confirm('Clear plan + actual + scratch for this date?')){
          state = { plan: [], actual: [], scratch: [] };
          save();
          render();
        }
      });
      document.getElementById('today').addEventListener('click', () => {
        dateInput.value = new Date().toISOString().slice(0,10);
        load();
      });
      dateInput.addEventListener('change', load);

      // Pomodoro: Work/Break only, manual between phases
      let pomo = {
        phase: 'Idle',     // Idle, Work, Break, Paused, Work done, Break done
        running: false,
        paused: false,
        timer: null,
        endAt: 0,
        startedAt: 0,
        durationMs: 0,
      };

      function cfg(){
        const workMin = clamp(parseInt(workMinEl.value,10) || 25, 1, 240);
        const breakMin = clamp(parseInt(breakMinEl.value,10) || 5, 1, 120);
        return { workMs: workMin * 60 * 1000, breakMs: breakMin * 60 * 1000 };
      }
      function mmss(ms){
        const s = Math.max(0, Math.floor(ms / 1000));
        const m = Math.floor(s / 60);
        const r = s % 60;
        return `${pad2(m)}:${pad2(r)}`;
      }
      function setPomoUI(){
        pomoStatus.textContent = pomo.phase;
        pomoLine.classList.remove('work','break');
        if(pomo.phase === 'Work') pomoLine.classList.add('work');
        if(pomo.phase === 'Break') pomoLine.classList.add('break');

        if(!pomo.running){
          pomoLeftEl.textContent = '—';
          return;
        }
        const left = pomo.paused ? (pomo.endAt - pomo.pauseAt) : (pomo.endAt - Date.now());
        pomoLeftEl.textContent = mmss(left);
      }

      function notify(title, body){
        try{
          if(Notification.permission === 'granted'){
            new Notification(title, { body });
          }
        }catch{}
      }
      function requestNotifications(){
        if(!('Notification' in window)){
          alert('Notifications not supported in this browser.');
          return;
        }
        Notification.requestPermission().then(p => {
          if(p === 'granted'){
            notify('Notifications enabled', 'Pomodoro alerts are ready.');
          }else{
            alert('Notification permission not granted.');
          }
        });
      }

      function startPhase(name, ms){
        pomo.phase = name;
        pomo.running = true;
        pomo.paused = false;
        pomo.startedAt = Date.now();
        pomo.durationMs = ms;
        pomo.endAt = Date.now() + ms;
        setPomoUI();
        tickPomo();
        renderPomodoroTracks();
        notify('Pomodoro', `${name} started (${Math.round(ms/60000)}m).`);
      }

      function stopPomo(){
        pomo.running = false;
        pomo.paused = false;
        pomo.phase = 'Idle';
        pomo.endAt = 0;
        pomo.startedAt = 0;
        pomo.durationMs = 0;
        if(pomo.timer) clearInterval(pomo.timer);
        pomo.timer = null;
        setPomoUI();
        renderPomodoroTracks();
      }

      function pausePomo(){
        if(!pomo.running || pomo.paused) return;
        pomo.paused = true;
        pomo.pauseAt = Date.now();
        pomo.phase = 'Paused';
        setPomoUI();
        renderPomodoroTracks();
      }

      function resumeIfPaused(targetPhase){
        if(!pomo.running || !pomo.paused) return false;
        pomo.paused = false;
        const pausedFor = Date.now() - pomo.pauseAt;
        pomo.endAt += pausedFor;
        pomo.phase = targetPhase;
        setPomoUI();
        renderPomodoroTracks();
        return true;
      }

      function tickPomo(){
        if(pomo.timer) clearInterval(pomo.timer);
        pomo.timer = setInterval(() => {
          if(!pomo.running) return;
          if(pomo.paused){
            setPomoUI();
            return;
          }
          const left = pomo.endAt - Date.now();
          setPomoUI();
          renderPomodoroTracks();
          if(left <= 0){
            const finished = pomo.phase;
            pomo.running = false;
            if(finished === 'Work'){
              pomo.phase = 'Work done';
              notify('Pomodoro', 'Work ended. Start Break when ready.');
            }else if(finished === 'Break'){
              pomo.phase = 'Break done';
              notify('Pomodoro', 'Break ended. Start Work when ready.');
            }
            setPomoUI();
            renderPomodoroTracks();
          }
        }, 250);
      }

      document.getElementById('notify').addEventListener('click', requestNotifications);
      document.getElementById('startWork').addEventListener('click', () => {
        const { workMs } = cfg();
        if(resumeIfPaused('Work')) return;
        startPhase('Work', workMs);
      });
      document.getElementById('startBreak').addEventListener('click', () => {
        const { breakMs } = cfg();
        if(resumeIfPaused('Break')) return;
        startPhase('Break', breakMs);
      });
      document.getElementById('pause').addEventListener('click', pausePomo);
      document.getElementById('stop').addEventListener('click', stopPomo);

      // Pomodoro blocks in tracks (no overlap with columns)
      function clearPomoBlocks(){
        [...pomoWorkTrack.querySelectorAll('.pomoBlock')].forEach(n => n.remove());
        [...pomoBreakTrack.querySelectorAll('.pomoBlock')].forEach(n => n.remove());
      }

      function renderPomodoroTracks(){
        clearPomoBlocks();

        const todayStr = new Date().toISOString().slice(0,10);
        const showDate = (dateInput.value === todayStr);
        const isActive = (pomo.running && !pomo.paused && (pomo.phase === 'Work' || pomo.phase === 'Break'));
        if(!showDate || !isActive) return;

        const now = Date.now();
        const started = pomo.startedAt || now;
        const endAt = pomo.endAt || now;

        const d = new Date();
        const dayNowMin = d.getHours() * 60 + d.getMinutes();

        const elapsedMin = Math.round(Math.max(0, (now - started)) / 60000);
        const remainingMin = Math.round(Math.max(0, (endAt - now)) / 60000);

        let startMin = snap(dayNowMin - elapsedMin);
        let endMin = snap(dayNowMin + remainingMin);

        startMin = clamp(startMin, 0, DAY_MIN);
        endMin = clamp(endMin, 0, DAY_MIN);
        if(endMin - startMin < snapMin) endMin = clamp(startMin + snapMin, 0, DAY_MIN);

        const top = minToY(startMin);
        const height = Math.max(10, minToY(endMin) - minToY(startMin));

        const block = document.createElement('div');
        block.className = 'pomoBlock' + (pomo.phase === 'Break' ? ' break' : '');
        block.style.top = `${top}px`;
        block.style.height = `${height}px`;

        if(pomo.phase === 'Work'){
          pomoWorkTrack.appendChild(block);
        }else{
          pomoBreakTrack.appendChild(block);
        }
      }

      // Init
      dateInput.value = new Date().toISOString().slice(0,10);
      setTitleForDate(dateInput.value);

      buildTimeline();
      attachDraw(planCol);
      attachDraw(actualCol);
      attachDraw(scratchCol);
      load();
      setPomoUI();
      updateNowLine();
      renderPomodoroTracks();

      setInterval(() => {
        updateNowLine();
        renderPomodoroTracks();
      }, 30_000);
    })();
  </script>
</body>
</html>
