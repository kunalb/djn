<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Day Plan / Actual</title>
  <style>
    :root{
      --bg:#0b0c10;
      --panel:#111318;
      --panel2:#0f1116;
      --text:#e9edf1;
      --muted:#9aa4af;
      --grid:#252a33;
      --grid2:#1a1f27;
      --accent:#7aa2ff;
      --accent2:#7dffb2;
      --danger:#ff6b6b;
      --shadow: 0 8px 26px rgba(0,0,0,.35);
      --radius: 14px;
      --colw: 1fr;
      --timelineW: 68px;
      --dayHeight: 1440px; /* 1px per minute */
      --snap: 5;           /* minutes snap */
    }

    * { box-sizing:border-box; }
    body{
      margin:0;
      background:linear-gradient(180deg, var(--bg), #07080b);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      letter-spacing: .2px;
    }

    .wrap{
      max-width: 1120px;
      margin: 18px auto 36px;
      padding: 0 14px;
    }

    .topbar{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      margin-bottom: 12px;
    }

    .title{
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .title h1{
      margin:0;
      font-size: 16px;
      font-weight: 700;
    }
    .title .hint{
      color: var(--muted);
      font-size: 12px;
    }

    .controls{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    .btn, .input, select{
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.10);
      color: var(--text);
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 12px;
      outline:none;
    }
    .btn{
      cursor:pointer;
      user-select:none;
      transition: transform .05s ease, border-color .2s ease, background .2s ease;
    }
    .btn:hover{
      border-color: rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.05);
    }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      border-color: rgba(122,162,255,0.5);
      background: rgba(122,162,255,0.10);
    }
    .btn.danger{
      border-color: rgba(255,107,107,0.5);
      background: rgba(255,107,107,0.10);
    }
    .btn.good{
      border-color: rgba(125,255,178,0.45);
      background: rgba(125,255,178,0.10);
    }

    .row{
      display:grid;
      grid-template-columns: var(--timelineW) var(--colw) var(--colw);
      gap: 10px;
      align-items:stretch;
    }

    .headerRow{
      margin-top: 10px;
      margin-bottom: 10px;
      display:grid;
      grid-template-columns: var(--timelineW) var(--colw) var(--colw);
      gap:10px;
      align-items:center;
    }
    .colTitle{
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: var(--radius);
      padding: 10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      box-shadow: var(--shadow);
    }
    .colTitle b{
      font-size: 12px;
      letter-spacing: .6px;
      text-transform: uppercase;
    }
    .colTitle span{
      color: var(--muted);
      font-size: 12px;
    }
    .spacer{ height:1px; }

    .timeline{
      position: relative;
      height: var(--dayHeight);
      border-radius: var(--radius);
      background: transparent;
      overflow:hidden;
    }
    .timeline .tick{
      position:absolute;
      left:0;
      width: 100%;
      transform: translateY(-0.5px);
      color: var(--muted);
      font-size: 11px;
      padding-left: 6px;
      display:flex;
      align-items:center;
      gap:6px;
      pointer-events:none;
      opacity:.9;
    }
    .timeline .tick .line{
      height:1px;
      flex:1;
      background: transparent;
    }

    .col{
      position: relative;
      height: var(--dayHeight);
      border-radius: var(--radius);
      background:
        linear-gradient(to bottom, rgba(255,255,255,0.02), rgba(255,255,255,0.01)),
        repeating-linear-gradient(
          to bottom,
          transparent 0px,
          transparent 29px,
          rgba(255,255,255,0.05) 30px
        );
      border: 1px solid rgba(255,255,255,0.08);
      overflow:hidden;
      box-shadow: var(--shadow);
    }
    .col::before{
      content:"";
      position:absolute; inset:0;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,0.04) 0px,
        rgba(255,255,255,0.04) 1px,
        transparent 1px,
        transparent 60px
      );
      pointer-events:none;
      opacity:.35;
    }

    .nowLine{
      position:absolute;
      left:0;
      right:0;
      height:1px;
      background: rgba(122,162,255,0.8);
      box-shadow: 0 0 0 2px rgba(122,162,255,0.12);
      pointer-events:none;
      z-index:5;
    }

    .block{
      position:absolute;
      left: 10px;
      right: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(122,162,255,0.18);
      backdrop-filter: blur(6px);
      padding: 8px 10px;
      cursor: grab;
      user-select:none;
      overflow:hidden;
      min-height: 12px;
      z-index: 10;
    }
    .block.actual{
      background: rgba(125,255,178,0.14);
      border-color: rgba(125,255,178,0.28);
    }
    .block .t{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom: 6px;
    }
    .block .label{
      font-size: 12px;
      font-weight: 650;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .block .time{
      font-size: 11px;
      color: rgba(233,237,241,0.80);
      white-space:nowrap;
    }
    .block .notes{
      font-size: 11px;
      color: rgba(233,237,241,0.82);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      opacity:.95;
    }

    .resizeHandle{
      position:absolute;
      left: 0;
      right: 0;
      height: 10px;
      cursor: ns-resize;
      opacity:.7;
    }
    .resizeHandle.top{ top: -2px; }
    .resizeHandle.bottom{ bottom: -2px; }

    .miniBtnRow{
      display:flex;
      gap:6px;
      align-items:center;
      opacity: 0;
      transition: opacity .15s ease;
    }
    .block:hover .miniBtnRow{ opacity: 1; }

    .miniBtn{
      font-size: 11px;
      padding: 4px 6px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.15);
      color: var(--text);
      cursor:pointer;
    }
    .miniBtn.del{
      border-color: rgba(255,107,107,0.35);
      background: rgba(255,107,107,0.10);
    }

    .footer{
      margin-top: 12px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }

    /* Pomodoro */
    .pomo{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: var(--radius);
      background: rgba(255,255,255,0.03);
      box-shadow: var(--shadow);
      margin-top: 12px;
    }
    .pomo .status{
      min-width: 170px;
      font-variant-numeric: tabular-nums;
    }
    .pomo small{ color: var(--muted); }
    .pomo .sep{ opacity:.35; padding: 0 4px; }

    /* Print */
    @media print{
      body{ background:#fff; color:#000; }
      .wrap{ max-width:none; margin:0; padding:0; }
      .topbar, .pomo, .footer{ display:none !important; }
      .colTitle{
        box-shadow:none;
        background:#fff;
        border: 1px solid #bbb;
        border-radius: 0;
      }
      .col{
        box-shadow:none;
        border-radius: 0;
        border: 1px solid #bbb;
        background: #fff;
      }
      .timeline{ border-radius:0; }
      .block{
        box-shadow:none;
        background: #eaefff;
        border: 1px solid #778;
      }
      .block.actual{
        background: #e9fff1;
        border: 1px solid #585;
      }
      .nowLine{ display:none !important; }
      .miniBtnRow{ display:none !important; }
      .row, .headerRow{ gap:6px; }
      @page { margin: 10mm; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="title">
        <h1>Day Plan / Actual</h1>
        <div class="hint">Drag to draw blocks. Drag blocks to move. Resize from edges. Double-click to edit. Autosaves per date.</div>
      </div>
      <div class="controls">
        <input class="input" id="date" type="date" />
        <button class="btn" id="today">Today</button>
        <button class="btn" id="clear">Clear</button>
        <button class="btn primary" id="print">Print / Save as PDF</button>
      </div>
    </div>

    <div class="headerRow">
      <div class="spacer"></div>
      <div class="colTitle"><b>Plan</b><span id="planSummary">—</span></div>
      <div class="colTitle"><b>Actual</b><span id="actualSummary">—</span></div>
    </div>

    <div class="row">
      <div class="timeline" id="timeline"></div>
      <div class="col" id="planCol" data-kind="plan"></div>
      <div class="col" id="actualCol" data-kind="actual"></div>
    </div>

    <div class="pomo">
      <div class="status">
        <div><b>Pomodoro</b> <span class="sep">•</span> <span id="pomoPhase">Idle</span></div>
        <div><small>Time left:</small> <span id="pomoLeft">—</span></div>
      </div>

      <label>
        <small>Work</small><br/>
        <input class="input" id="workMin" type="number" min="1" value="25" style="width:72px" />
      </label>
      <label>
        <small>Break</small><br/>
        <input class="input" id="breakMin" type="number" min="1" value="5" style="width:72px" />
      </label>
      <label>
        <small>Long break</small><br/>
        <input class="input" id="longBreakMin" type="number" min="1" value="15" style="width:92px" />
      </label>
      <label>
        <small>Every</small><br/>
        <input class="input" id="longEvery" type="number" min="2" value="4" style="width:72px" />
      </label>
      <label>
        <small>Cycles</small><br/>
        <input class="input" id="cycles" type="number" min="1" value="8" style="width:72px" />
      </label>

      <button class="btn good" id="notify">Enable notifications</button>
      <button class="btn" id="pomoStart">Start</button>
      <button class="btn" id="pomoPause">Pause</button>
      <button class="btn danger" id="pomoStop">Stop</button>
      <button class="btn primary" id="pomoFill">Auto-fill Plan</button>

      <div style="flex:1"></div>
      <small>Tip: notifications need permission; leave this tab open.</small>
    </div>

    <div class="footer">
      Printing: use your browser’s print dialog (Ctrl/Cmd+P) and choose “Save as PDF” if you want a PDF file.
    </div>
  </div>

  <script>
    (() => {
      const DAY_MIN = 24 * 60;
      const dayHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--dayHeight'), 10);
      const snapMin = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--snap'), 10);
      const pxPerMin = dayHeight / DAY_MIN;

      const timeline = document.getElementById('timeline');
      const planCol = document.getElementById('planCol');
      const actualCol = document.getElementById('actualCol');
      const dateInput = document.getElementById('date');

      const planSummary = document.getElementById('planSummary');
      const actualSummary = document.getElementById('actualSummary');

      // Pomodoro elements
      const pomoPhase = document.getElementById('pomoPhase');
      const pomoLeft = document.getElementById('pomoLeft');
      const workMinEl = document.getElementById('workMin');
      const breakMinEl = document.getElementById('breakMin');
      const longBreakMinEl = document.getElementById('longBreakMin');
      const longEveryEl = document.getElementById('longEvery');
      const cyclesEl = document.getElementById('cycles');

      let state = {
        plan: [],
        actual: []
      };

      function yToMin(y){
        const m = Math.round(y / pxPerMin);
        return clamp(m, 0, DAY_MIN);
      }
      function minToY(min){
        return min * pxPerMin;
      }
      function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
      function snap(min){
        return Math.round(min / snapMin) * snapMin;
      }
      function pad2(n){ return String(n).padStart(2,'0'); }
      function fmtTime(min){
        const h = Math.floor(min / 60);
        const m = min % 60;
        return `${pad2(h)}:${pad2(m)}`;
      }
      function fmtDur(min){
        const h = Math.floor(min / 60);
        const m = min % 60;
        if(h === 0) return `${m}m`;
        if(m === 0) return `${h}h`;
        return `${h}h ${m}m`;
      }

      function storageKey(dateStr){
        return `daytool:v1:${dateStr}`;
      }
      function load(){
        const key = storageKey(dateInput.value);
        const raw = localStorage.getItem(key);
        if(!raw){
          state = { plan: [], actual: [] };
          render();
          return;
        }
        try{
          const parsed = JSON.parse(raw);
          state = {
            plan: Array.isArray(parsed.plan) ? parsed.plan : [],
            actual: Array.isArray(parsed.actual) ? parsed.actual : []
          };
        }catch{
          state = { plan: [], actual: [] };
        }
        render();
      }
      function save(){
        const key = storageKey(dateInput.value);
        localStorage.setItem(key, JSON.stringify(state));
        updateSummaries();
      }

      function updateSummaries(){
        function sum(list){
          let total = 0;
          for(const b of list) total += Math.max(0, (b.end - b.start));
          return total;
        }
        planSummary.textContent = fmtDur(sum(state.plan));
        actualSummary.textContent = fmtDur(sum(state.actual));
      }

      // Timeline ticks every hour
      function buildTimeline(){
        timeline.innerHTML = '';
        for(let h = 0; h <= 24; h++){
          const y = minToY(h * 60);
          const tick = document.createElement('div');
          tick.className = 'tick';
          tick.style.top = `${y}px`;
          const label = (h === 24) ? '24:00' : `${pad2(h)}:00`;
          tick.innerHTML = `<div style="width:52px">${label}</div><div class="line"></div>`;
          timeline.appendChild(tick);
        }
      }

      // Now line
      const nowLinePlan = document.createElement('div');
      nowLinePlan.className = 'nowLine';
      const nowLineActual = document.createElement('div');
      nowLineActual.className = 'nowLine';
      planCol.appendChild(nowLinePlan);
      actualCol.appendChild(nowLineActual);

      function updateNowLine(){
        const d = new Date();
        // Only show "now" line when viewing today's date
        const todayStr = d.toISOString().slice(0,10);
        const show = (dateInput.value === todayStr);
        nowLinePlan.style.display = show ? 'block' : 'none';
        nowLineActual.style.display = show ? 'block' : 'none';
        if(!show) return;
        const min = d.getHours() * 60 + d.getMinutes();
        const y = minToY(min);
        nowLinePlan.style.top = `${y}px`;
        nowLineActual.style.top = `${y}px`;
      }

      function render(){
        // Clear blocks (keep now line)
        for(const col of [planCol, actualCol]){
          [...col.querySelectorAll('.block')].forEach(n => n.remove());
        }

        for(const b of state.plan) createBlockEl(planCol, b);
        for(const b of state.actual) createBlockEl(actualCol, b);

        updateSummaries();
        updateNowLine();
      }

      function sortAndNormalize(kind){
        const arr = state[kind];
        arr.sort((a,b) => a.start - b.start);
      }

      function newId(){
        return Math.random().toString(16).slice(2) + Date.now().toString(16);
      }

      function createBlock(kind, start, end, label='(untitled)', notes=''){
        const s = clamp(snap(start), 0, DAY_MIN);
        const e = clamp(snap(end), 0, DAY_MIN);
        if(Math.abs(e - s) < snapMin) return null;
        const b = { id: newId(), start: Math.min(s,e), end: Math.max(s,e), label, notes };
        state[kind].push(b);
        sortAndNormalize(kind);
        save();
        render();
        return b;
      }

      function removeBlock(kind, id){
        state[kind] = state[kind].filter(b => b.id !== id);
        save();
        render();
      }

      function updateBlock(kind, id, patch){
        const b = state[kind].find(x => x.id === id);
        if(!b) return;
        Object.assign(b, patch);
        b.start = clamp(snap(b.start), 0, DAY_MIN);
        b.end = clamp(snap(b.end), 0, DAY_MIN);
        if(b.end < b.start) [b.start, b.end] = [b.end, b.start];
        if(b.end - b.start < snapMin) b.end = clamp(b.start + snapMin, 0, DAY_MIN);
        sortAndNormalize(kind);
        save();
        render();
      }

      function createBlockEl(col, b){
        const kind = col.dataset.kind;

        const el = document.createElement('div');
        el.className = 'block' + (kind === 'actual' ? ' actual' : '');
        el.dataset.id = b.id;

        const top = minToY(b.start);
        const height = Math.max(8, minToY(b.end) - minToY(b.start));
        el.style.top = `${top}px`;
        el.style.height = `${height}px`;

        el.innerHTML = `
          <div class="resizeHandle top" data-handle="top"></div>
          <div class="resizeHandle bottom" data-handle="bottom"></div>
          <div class="t">
            <div class="label" title="${escapeHtml(b.label)}">${escapeHtml(b.label)}</div>
            <div class="miniBtnRow">
              <button class="miniBtn" data-action="edit">Edit</button>
              <button class="miniBtn del" data-action="del">Delete</button>
            </div>
          </div>
          <div class="time">${fmtTime(b.start)}–${fmtTime(b.end)} <span style="opacity:.7">(${fmtDur(b.end-b.start)})</span></div>
          <div class="notes" title="${escapeHtml(b.notes||'')}">${escapeHtml(b.notes||'')}</div>
        `;

        // Buttons
        el.addEventListener('click', (ev) => {
          const btn = ev.target.closest('button');
          if(!btn) return;
          const act = btn.dataset.action;
          if(act === 'del'){
            ev.stopPropagation();
            removeBlock(kind, b.id);
          }else if(act === 'edit'){
            ev.stopPropagation();
            editBlock(kind, b.id);
          }
        });
        el.addEventListener('dblclick', (ev) => {
          // Ignore if resizing/dragging; still allow quick edit
          ev.stopPropagation();
          editBlock(kind, b.id);
        });

        // Drag / resize
        el.addEventListener('pointerdown', (ev) => {
          const handle = ev.target.closest('.resizeHandle');
          if(handle){
            startResize(ev, col, kind, b.id, handle.dataset.handle);
            return;
          }
          // Ignore clicking on buttons
          if(ev.target.closest('button')) return;
          startMove(ev, col, kind, b.id);
        });

        col.appendChild(el);
      }

      function escapeHtml(s){
        return String(s)
          .replaceAll('&','&amp;')
          .replaceAll('<','&lt;')
          .replaceAll('>','&gt;')
          .replaceAll('"','&quot;')
          .replaceAll("'","&#39;");
      }

      function editBlock(kind, id){
        const b = state[kind].find(x => x.id === id);
        if(!b) return;
        const label = prompt('Label:', b.label);
        if(label === null) return;
        const notes = prompt('Notes (optional):', b.notes || '');
        if(notes === null) return;
        updateBlock(kind, id, { label: label.trim() || '(untitled)', notes: notes.trim() });
      }

      // Drawing blocks on empty space
      function attachDraw(col){
        let drawing = null;

        col.addEventListener('pointerdown', (ev) => {
          // If clicking on existing block, let its handler handle it
          if(ev.target.closest('.block')) return;

          col.setPointerCapture(ev.pointerId);
          const kind = col.dataset.kind;
          const rect = col.getBoundingClientRect();
          const y0 = clamp(ev.clientY - rect.top, 0, dayHeight);
          const startMin = snap(yToMin(y0));
          drawing = { kind, startMin, currentMin: startMin };

          // Create a temp visual block
          const temp = document.createElement('div');
          temp.className = 'block' + (kind === 'actual' ? ' actual' : '');
          temp.style.left = '10px';
          temp.style.right = '10px';
          temp.style.top = `${minToY(startMin)}px`;
          temp.style.height = `${minToY(startMin + snapMin) - minToY(startMin)}px`;
          temp.style.opacity = '0.85';
          temp.style.cursor = 'crosshair';
          temp.innerHTML = `<div class="time">${fmtTime(startMin)}–${fmtTime(startMin)} <span style="opacity:.7">(drawing)</span></div>`;
          col.appendChild(temp);
          drawing.temp = temp;

          ev.preventDefault();
        });

        col.addEventListener('pointermove', (ev) => {
          if(!drawing) return;
          const rect = col.getBoundingClientRect();
          const y = clamp(ev.clientY - rect.top, 0, dayHeight);
          const m = snap(yToMin(y));
          drawing.currentMin = m;

          const a = Math.min(drawing.startMin, drawing.currentMin);
          const b = Math.max(drawing.startMin, drawing.currentMin);
          const top = minToY(a);
          const height = Math.max(8, minToY(b) - minToY(a));
          drawing.temp.style.top = `${top}px`;
          drawing.temp.style.height = `${height}px`;
          drawing.temp.querySelector('.time').textContent = `${fmtTime(a)}–${fmtTime(b)} (drawing)`;
        });

        col.addEventListener('pointerup', (ev) => {
          if(!drawing) return;
          const kind = drawing.kind;
          const a = Math.min(drawing.startMin, drawing.currentMin);
          const b = Math.max(drawing.startMin, drawing.currentMin);
          drawing.temp.remove();
          drawing = null;

          // Create real block
          const label = prompt('Label:', kind === 'plan' ? 'Work' : 'What I did');
          if(label === null) return;
          const notes = prompt('Notes (optional):', '');
          if(notes === null) return;
          createBlock(kind, a, b, label.trim() || '(untitled)', notes.trim());
        });
      }

      // Move blocks
      function startMove(ev, col, kind, id){
        const el = col.querySelector(`.block[data-id="${CSS.escape(id)}"]`);
        if(!el) return;

        el.style.cursor = 'grabbing';
        el.setPointerCapture(ev.pointerId);

        const rect = col.getBoundingClientRect();
        const startY = clamp(ev.clientY - rect.top, 0, dayHeight);
        const b = state[kind].find(x => x.id === id);
        const dur = b.end - b.start;
        const origStart = b.start;

        function onMove(e){
          const y = clamp(e.clientY - rect.top, 0, dayHeight);
          const deltaMin = snap(yToMin(y - startY));
          let newStart = snap(origStart + deltaMin);
          newStart = clamp(newStart, 0, DAY_MIN - dur);
          updateBlock(kind, id, { start: newStart, end: newStart + dur });
        }
        function onUp(){
          el.style.cursor = 'grab';
          window.removeEventListener('pointermove', onMove);
          window.removeEventListener('pointerup', onUp);
        }

        window.addEventListener('pointermove', onMove);
        window.addEventListener('pointerup', onUp);
      }

      // Resize blocks
      function startResize(ev, col, kind, id, which){
        const el = col.querySelector(`.block[data-id="${CSS.escape(id)}"]`);
        if(!el) return;
        el.setPointerCapture(ev.pointerId);

        const rect = col.getBoundingClientRect();
        const b = state[kind].find(x => x.id === id);
        const origStart = b.start;
        const origEnd = b.end;

        function onMove(e){
          const y = clamp(e.clientY - rect.top, 0, dayHeight);
          const m = snap(yToMin(y));
          if(which === 'top'){
            const newStart = clamp(m, 0, origEnd - snapMin);
            updateBlock(kind, id, { start: newStart, end: origEnd });
          }else{
            const newEnd = clamp(m, origStart + snapMin, DAY_MIN);
            updateBlock(kind, id, { start: origStart, end: newEnd });
          }
        }
        function onUp(){
          window.removeEventListener('pointermove', onMove);
          window.removeEventListener('pointerup', onUp);
        }

        window.addEventListener('pointermove', onMove);
        window.addEventListener('pointerup', onUp);
        ev.preventDefault();
      }

      // Buttons
      document.getElementById('print').addEventListener('click', () => window.print());
      document.getElementById('clear').addEventListener('click', () => {
        if(confirm('Clear plan + actual for this date?')){
          state = { plan: [], actual: [] };
          save();
          render();
        }
      });
      document.getElementById('today').addEventListener('click', () => {
        const d = new Date();
        dateInput.value = d.toISOString().slice(0,10);
        load();
      });

      dateInput.addEventListener('change', load);

      // Init date
      (() => {
        const d = new Date();
        dateInput.value = d.toISOString().slice(0,10);
      })();

      // Pomodoro
      let pomo = {
        running: false,
        paused: false,
        timer: null,
        phase: 'Idle', // Work, Break, Long Break
        phaseIndex: 0,
        endAt: 0,
        cyclesDone: 0,
      };

      function notify(title, body){
        try{
          if(Notification.permission === 'granted'){
            new Notification(title, { body });
          }
        }catch{}
      }

      function requestNotifications(){
        if(!('Notification' in window)){
          alert('Notifications not supported in this browser.');
          return;
        }
        Notification.requestPermission().then(p => {
          if(p === 'granted'){
            notify('Notifications enabled', 'Pomodoro alerts are ready.');
          }else{
            alert('Notification permission not granted.');
          }
        });
      }

      function mmss(ms){
        const s = Math.max(0, Math.floor(ms / 1000));
        const m = Math.floor(s / 60);
        const r = s % 60;
        return `${pad2(m)}:${pad2(r)}`;
      }

      function pomoConfig(){
        return {
          work: clamp(parseInt(workMinEl.value,10) || 25, 1, 240) * 60 * 1000,
          brk: clamp(parseInt(breakMinEl.value,10) || 5, 1, 120) * 60 * 1000,
          longBrk: clamp(parseInt(longBreakMinEl.value,10) || 15, 1, 240) * 60 * 1000,
          longEvery: clamp(parseInt(longEveryEl.value,10) || 4, 2, 12),
          cycles: clamp(parseInt(cyclesEl.value,10) || 8, 1, 48),
        };
      }

      function setPomoUI(){
        pomoPhase.textContent = pomo.phase;
        if(!pomo.running){
          pomoLeft.textContent = '—';
          return;
        }
        const left = pomo.paused ? (pomo.endAt - pomo.pauseAt) : (pomo.endAt - Date.now());
        pomoLeft.textContent = mmss(left);
      }

      function startPhase(name, ms){
        pomo.phase = name;
        pomo.running = true;
        pomo.paused = false;
        pomo.endAt = Date.now() + ms;
        setPomoUI();
        tickPomo();
        notify('Pomodoro', `${name} started (${Math.round(ms/60000)}m).`);
      }

      function nextPhase(){
        const cfg = pomoConfig();
        // Sequence: Work -> Break, with Long Break every N works.
        // Stop after cfg.cycles Work phases completed.
        if(pomo.phase === 'Idle'){
          pomo.cyclesDone = 0;
          startPhase('Work', cfg.work);
          return;
        }

        if(pomo.phase === 'Work'){
          pomo.cyclesDone += 1;
          if(pomo.cyclesDone >= cfg.cycles){
            stopPomo();
            notify('Pomodoro', `Done. Completed ${cfg.cycles} work cycles.`);
            return;
          }
          const isLong = (pomo.cyclesDone % cfg.longEvery === 0);
          startPhase(isLong ? 'Long Break' : 'Break', isLong ? cfg.longBrk : cfg.brk);
          return;
        }

        // Break -> Work
        startPhase('Work', cfg.work);
      }

      function tickPomo(){
        if(pomo.timer) clearInterval(pomo.timer);
        pomo.timer = setInterval(() => {
          if(!pomo.running) return;
          if(pomo.paused){
            setPomoUI();
            return;
          }
          const left = pomo.endAt - Date.now();
          setPomoUI();
          if(left <= 0){
            notify('Pomodoro', `${pomo.phase} ended.`);
            nextPhase();
          }
        }, 250);
      }

      function startPomo(){
        if(!('Notification' in window)){
          // ok; we can still run without notifications
        }
        if(pomo.running && pomo.paused){
          // resume
          pomo.paused = false;
          const pausedFor = Date.now() - pomo.pauseAt;
          pomo.endAt += pausedFor;
          setPomoUI();
          return;
        }
        if(pomo.running) return;
        nextPhase(); // from Idle
      }

      function pausePomo(){
        if(!pomo.running || pomo.paused) return;
        pomo.paused = true;
        pomo.pauseAt = Date.now();
        setPomoUI();
      }

      function stopPomo(){
        pomo.running = false;
        pomo.paused = false;
        pomo.phase = 'Idle';
        pomo.endAt = 0;
        if(pomo.timer) clearInterval(pomo.timer);
        pomo.timer = null;
        setPomoUI();
      }

      document.getElementById('notify').addEventListener('click', requestNotifications);
      document.getElementById('pomoStart').addEventListener('click', startPomo);
      document.getElementById('pomoPause').addEventListener('click', pausePomo);
      document.getElementById('pomoStop').addEventListener('click', stopPomo);

      // Auto-fill plan with Pomodoro blocks starting now (rounded)
      document.getElementById('pomoFill').addEventListener('click', () => {
        const cfg = pomoConfig();
        const d = new Date();
        const nowMin = d.getHours() * 60 + d.getMinutes();
        let start = snap(nowMin);

        // round up to next snap boundary for nicer starts
        if(start < nowMin) start += snapMin;

        // Build blocks for cfg.cycles work phases
        const blocks = [];
        let worksDone = 0;
        while(worksDone < cfg.cycles && start < DAY_MIN){
          // Work
          const wStart = start;
          const wEnd = clamp(wStart + Math.round(cfg.work / 60000), 0, DAY_MIN);
          blocks.push({ kind:'plan', start:wStart, end:wEnd, label:'Focus', notes:'Pomodoro work' });
          worksDone += 1;
          start = wEnd;

          if(worksDone >= cfg.cycles || start >= DAY_MIN) break;

          // Break
          const isLong = (worksDone % cfg.longEvery === 0);
          const breakMins = Math.round((isLong ? cfg.longBrk : cfg.brk) / 60000);
          const bStart = start;
          const bEnd = clamp(bStart + breakMins, 0, DAY_MIN);
          blocks.push({ kind:'plan', start:bStart, end:bEnd, label:isLong ? 'Long break' : 'Break', notes:'Pomodoro break' });
          start = bEnd;
        }

        // Apply: replace current plan after "start time"? keep existing? minimal choice: append.
        // We'll append but avoid exact duplicate blocks at same times/labels.
        for(const x of blocks){
          const exists = state.plan.some(b => b.start === x.start && b.end === x.end && b.label === x.label);
          if(!exists){
            state.plan.push({ id:newId(), start:x.start, end:x.end, label:x.label, notes:x.notes });
          }
        }
        sortAndNormalize('plan');
        save();
        render();
      });

      // Hook drawing
      attachDraw(planCol);
      attachDraw(actualCol);

      // Init
      buildTimeline();
      load();
      setPomoUI();
      updateNowLine();
      setInterval(updateNowLine, 30_000);
    })();
  </script>
</body>
</html>
