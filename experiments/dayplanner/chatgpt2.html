<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Day Plan / Actual</title>
  <style>
    :root{
      --bg:#0b0c10;
      --panel:#111318;
      --text:#e9edf1;
      --muted:#9aa4af;
      --accent:#7aa2ff;
      --accent2:#7dffb2;
      --danger:#ff6b6b;
      --shadow: 0 8px 26px rgba(0,0,0,.35);
      --radius: 14px;
      --timelineW: 68px;
      --dayHeight: 1440px; /* 1px per minute */
      --snap: 5;           /* minutes snap */
    }

    * { box-sizing:border-box; }
    body{
      margin:0;
      background:linear-gradient(180deg, var(--bg), #07080b);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      letter-spacing: .2px;
    }

    .wrap{
      max-width: 1120px;
      margin: 18px auto 36px;
      padding: 0 14px;
    }

    .topbar{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      margin-bottom: 10px;
      flex-wrap:wrap;
    }

    .title{
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .title h1{
      margin:0;
      font-size: 16px;
      font-weight: 700;
    }
    .title .hint{
      color: var(--muted);
      font-size: 12px;
      line-height: 1.25;
      max-width: 680px;
    }

    .controls{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    .btn, .input{
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.10);
      color: var(--text);
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 12px;
      outline:none;
    }
    .btn{
      cursor:pointer;
      user-select:none;
      transition: transform .05s ease, border-color .2s ease, background .2s ease;
    }
    .btn:hover{
      border-color: rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.05);
    }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      border-color: rgba(122,162,255,0.5);
      background: rgba(122,162,255,0.10);
    }
    .btn.good{
      border-color: rgba(125,255,178,0.45);
      background: rgba(125,255,178,0.10);
    }
    .btn.danger{
      border-color: rgba(255,107,107,0.5);
      background: rgba(255,107,107,0.10);
    }

    /* Pomodoro box moved to top */
    .pomo{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: var(--radius);
      background: rgba(255,255,255,0.03);
      box-shadow: var(--shadow);
      margin-bottom: 12px;
    }
    .pomo .status{
      min-width: 210px;
      font-variant-numeric: tabular-nums;
    }
    .pomo small{ color: var(--muted); }
    .pomo .sep{ opacity:.35; padding: 0 4px; }
    .pomo .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.12);
      font-size: 12px;
    }

    .headerRow{
      margin-top: 10px;
      margin-bottom: 10px;
      display:grid;
      grid-template-columns: var(--timelineW) 1fr 1fr;
      gap:10px;
      align-items:center;
    }
    .colTitle{
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: var(--radius);
      padding: 10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      box-shadow: var(--shadow);
    }
    .colTitle b{
      font-size: 12px;
      letter-spacing: .6px;
      text-transform: uppercase;
    }
    .colTitle span{
      color: var(--muted);
      font-size: 12px;
    }
    .spacer{ height:1px; }

    .row{
      display:grid;
      grid-template-columns: var(--timelineW) 1fr 1fr;
      gap: 10px;
      align-items:stretch;
    }

    .timeline{
      position: relative;
      height: var(--dayHeight);
      border-radius: var(--radius);
      background: transparent;
      overflow:hidden;
    }
    .timeline .tick{
      position:absolute;
      left:0;
      width: 100%;
      transform: translateY(-0.5px);
      color: var(--muted);
      font-size: 11px;
      padding-left: 6px;
      display:flex;
      align-items:center;
      gap:6px;
      pointer-events:none;
      opacity:.9;
    }
    .timeline .tick .line{
      height:1px;
      flex:1;
      background: transparent;
    }

    .col{
      position: relative;
      height: var(--dayHeight);
      border-radius: var(--radius);
      background:
        linear-gradient(to bottom, rgba(255,255,255,0.02), rgba(255,255,255,0.01)),
        repeating-linear-gradient(to bottom, transparent 0px, transparent 29px, rgba(255,255,255,0.05) 30px);
      border: 1px solid rgba(255,255,255,0.08);
      overflow:hidden;
      box-shadow: var(--shadow);
    }
    .col::before{
      content:"";
      position:absolute; inset:0;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,0.04) 0px,
        rgba(255,255,255,0.04) 1px,
        transparent 1px,
        transparent 60px
      );
      pointer-events:none;
      opacity:.35;
    }

    .nowLine{
      position:absolute;
      left:0;
      right:0;
      height:1px;
      background: rgba(122,162,255,0.8);
      box-shadow: 0 0 0 2px rgba(122,162,255,0.12);
      pointer-events:none;
      z-index:5;
    }

    .block{
      position:absolute;
      left: 10px;
      right: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(122,162,255,0.18);
      backdrop-filter: blur(6px);
      padding: 8px 10px;
      cursor: grab;
      user-select:none;
      overflow:hidden;
      min-height: 12px;
      z-index: 10;
    }
    .block.actual{
      background: rgba(125,255,178,0.14);
      border-color: rgba(125,255,178,0.28);
    }
    .block.pomoActive{
      background: rgba(122,162,255,0.10);
      border-color: rgba(122,162,255,0.55);
      border-style: dashed;
      z-index: 30;
      pointer-events:none; /* ghost overlay */
    }
    .block .t{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      margin-bottom: 6px;
    }
    .block .label{
      font-size: 12px;
      font-weight: 650;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      outline:none;
      padding: 2px 0;
    }
    .block .label[contenteditable="true"]{
      cursor:text;
      user-select:text;
    }
    .block .label[contenteditable="true"]:focus{
      white-space:normal;
      text-overflow:clip;
    }

    .block .time{
      font-size: 11px;
      color: rgba(233,237,241,0.80);
      white-space:nowrap;
    }

    .resizeHandle{
      position:absolute;
      left: 0;
      right: 0;
      height: 10px;
      cursor: ns-resize;
      opacity:.7;
    }
    .resizeHandle.top{ top: -2px; }
    .resizeHandle.bottom{ bottom: -2px; }

    .miniBtnRow{
      display:flex;
      gap:6px;
      align-items:center;
      opacity: 0;
      transition: opacity .15s ease;
      flex-shrink:0;
    }
    .block:hover .miniBtnRow{ opacity: 1; }

    .miniBtn{
      font-size: 11px;
      padding: 4px 6px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.15);
      color: var(--text);
      cursor:pointer;
    }
    .miniBtn.del{
      border-color: rgba(255,107,107,0.35);
      background: rgba(255,107,107,0.10);
    }

    .footer{
      margin-top: 12px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }

    /* Print */
    @media print{
      body{ background:#fff; color:#000; }
      .wrap{ max-width:none; margin:0; padding:0; }
      .topbar, .pomo, .footer{ display:none !important; }
      .colTitle{
        box-shadow:none;
        background:#fff;
        border: 1px solid #bbb;
        border-radius: 0;
      }
      .col{
        box-shadow:none;
        border-radius: 0;
        border: 1px solid #bbb;
        background: #fff;
      }
      .timeline{ border-radius:0; }
      .block{
        box-shadow:none;
        background: #eaefff;
        border: 1px solid #778;
      }
      .block.actual{
        background: #e9fff1;
        border: 1px solid #585;
      }
      .block.pomoActive{
        display:none !important;
      }
      .nowLine{ display:none !important; }
      .miniBtnRow{ display:none !important; }
      .row, .headerRow{ gap:6px; }
      @page { margin: 10mm; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="title">
        <h1>Day Plan / Actual</h1>
        <div class="hint">Drag to draw blocks. Drag blocks to move. Resize from edges. Click text to edit inline. Autosaves per date.</div>
      </div>
      <div class="controls">
        <input class="input" id="date" type="date" />
        <button class="btn" id="today">Today</button>
        <button class="btn danger" id="clear">Clear</button>
        <button class="btn primary" id="print">Print / Save as PDF</button>
      </div>
    </div>

    <!-- Pomodoro at top -->
    <div class="pomo">
      <div class="status">
        <div><b>Pomodoro</b> <span class="sep">•</span> <span id="pomoPhase">Idle</span></div>
        <div><small>Time left:</small> <span id="pomoLeft">—</span></div>
      </div>

      <span class="pill">
        <small>Work</small>
        <input class="input" id="workMin" type="number" min="1" value="25" style="width:72px" />
        <small>min</small>
      </span>
      <span class="pill">
        <small>Break</small>
        <input class="input" id="breakMin" type="number" min="1" value="5" style="width:72px" />
        <small>min</small>
      </span>

      <button class="btn good" id="notify">Enable notifications</button>
      <button class="btn primary" id="pomoStartWork">Start work</button>
      <button class="btn" id="pomoStartBreak">Start break</button>
      <button class="btn" id="pomoPause">Pause</button>
      <button class="btn danger" id="pomoStop">Stop</button>

      <div style="flex:1"></div>
      <small>When a phase ends, it waits for you to start the next.</small>
    </div>

    <div class="headerRow">
      <div class="spacer"></div>
      <div class="colTitle"><b>Plan</b><span id="planSummary">—</span></div>
      <div class="colTitle"><b>Actual</b><span id="actualSummary">—</span></div>
    </div>

    <div class="row">
      <div class="timeline" id="timeline"></div>
      <div class="col" id="planCol" data-kind="plan"></div>
      <div class="col" id="actualCol" data-kind="actual"></div>
    </div>

    <div class="footer">
      Printing: use your browser’s print dialog (Ctrl/Cmd+P) and choose “Save as PDF” if you want a PDF file.
    </div>
  </div>

  <script>
    (() => {
      const DAY_MIN = 24 * 60;
      const dayHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--dayHeight'), 10);
      const snapMin = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--snap'), 10);
      const pxPerMin = dayHeight / DAY_MIN;

      const timeline = document.getElementById('timeline');
      const planCol = document.getElementById('planCol');
      const actualCol = document.getElementById('actualCol');
      const dateInput = document.getElementById('date');

      const planSummary = document.getElementById('planSummary');
      const actualSummary = document.getElementById('actualSummary');

      // Pomodoro
      const pomoPhaseEl = document.getElementById('pomoPhase');
      const pomoLeftEl = document.getElementById('pomoLeft');
      const workMinEl = document.getElementById('workMin');
      const breakMinEl = document.getElementById('breakMin');

      let state = { plan: [], actual: [] };

      function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
      function snap(min){ return Math.round(min / snapMin) * snapMin; }
      function yToMin(y){ return clamp(Math.round(y / pxPerMin), 0, DAY_MIN); }
      function minToY(min){ return min * pxPerMin; }
      function pad2(n){ return String(n).padStart(2,'0'); }
      function fmtTime(min){
        const h = Math.floor(min / 60);
        const m = min % 60;
        return `${pad2(h)}:${pad2(m)}`;
      }
      function fmtDur(min){
        const h = Math.floor(min / 60);
        const m = min % 60;
        if(h === 0) return `${m}m`;
        if(m === 0) return `${h}h`;
        return `${h}h ${m}m`;
      }
      function storageKey(dateStr){ return `daytool:v2:${dateStr}`; }
      function newId(){ return Math.random().toString(16).slice(2) + Date.now().toString(16); }

      function sumDur(list){
        let total = 0;
        for(const b of list) total += Math.max(0, (b.end - b.start));
        return total;
      }
      function updateSummaries(){
        planSummary.textContent = fmtDur(sumDur(state.plan));
        actualSummary.textContent = fmtDur(sumDur(state.actual));
      }

      function save(){
        localStorage.setItem(storageKey(dateInput.value), JSON.stringify(state));
        updateSummaries();
      }
      function load(){
        const raw = localStorage.getItem(storageKey(dateInput.value));
        if(!raw){
          state = { plan: [], actual: [] };
          render();
          return;
        }
        try{
          const parsed = JSON.parse(raw);
          state = {
            plan: Array.isArray(parsed.plan) ? parsed.plan : [],
            actual: Array.isArray(parsed.actual) ? parsed.actual : []
          };
        }catch{
          state = { plan: [], actual: [] };
        }
        render();
      }

      function buildTimeline(){
        timeline.innerHTML = '';
        for(let h = 0; h <= 24; h++){
          const y = minToY(h * 60);
          const tick = document.createElement('div');
          tick.className = 'tick';
          tick.style.top = `${y}px`;
          const label = (h === 24) ? '24:00' : `${pad2(h)}:00`;
          tick.innerHTML = `<div style="width:52px">${label}</div><div class="line"></div>`;
          timeline.appendChild(tick);
        }
      }

      // Now line
      const nowLinePlan = document.createElement('div');
      nowLinePlan.className = 'nowLine';
      const nowLineActual = document.createElement('div');
      nowLineActual.className = 'nowLine';
      planCol.appendChild(nowLinePlan);
      actualCol.appendChild(nowLineActual);

      function updateNowLine(){
        const d = new Date();
        const todayStr = d.toISOString().slice(0,10);
        const show = (dateInput.value === todayStr);
        nowLinePlan.style.display = show ? 'block' : 'none';
        nowLineActual.style.display = show ? 'block' : 'none';
        if(!show) return;
        const min = d.getHours() * 60 + d.getMinutes();
        const y = minToY(min);
        nowLinePlan.style.top = `${y}px`;
        nowLineActual.style.top = `${y}px`;
      }

      function sortKind(kind){
        state[kind].sort((a,b) => a.start - b.start);
      }

      function createBlock(kind, start, end, label=''){
        const s = clamp(snap(start), 0, DAY_MIN);
        const e = clamp(snap(end), 0, DAY_MIN);
        if(Math.abs(e - s) < snapMin) return null;
        const b = {
          id: newId(),
          start: Math.min(s,e),
          end: Math.max(s,e),
          label: label
        };
        state[kind].push(b);
        sortKind(kind);
        save();
        render();
        return b;
      }

      function removeBlock(kind, id){
        state[kind] = state[kind].filter(b => b.id !== id);
        save();
        render();
      }

      function updateBlock(kind, id, patch){
        const b = state[kind].find(x => x.id === id);
        if(!b) return;
        Object.assign(b, patch);
        b.start = clamp(snap(b.start), 0, DAY_MIN);
        b.end = clamp(snap(b.end), 0, DAY_MIN);
        if(b.end < b.start) [b.start, b.end] = [b.end, b.start];
        if(b.end - b.start < snapMin) b.end = clamp(b.start + snapMin, 0, DAY_MIN);
        sortKind(kind);
        save();
        // Don't full render on every keystroke; only render for move/resize.
      }

      function render(){
        for(const col of [planCol, actualCol]){
          [...col.querySelectorAll('.block:not(.pomoActive)')].forEach(n => n.remove());
        }
        for(const b of state.plan) createBlockEl(planCol, b);
        for(const b of state.actual) createBlockEl(actualCol, b);
        updateSummaries();
        updateNowLine();
        renderPomodoroOverlay();
      }

      function createBlockEl(col, b){
        const kind = col.dataset.kind;

        const el = document.createElement('div');
        el.className = 'block' + (kind === 'actual' ? ' actual' : '');
        el.dataset.id = b.id;

        const top = minToY(b.start);
        const height = Math.max(8, minToY(b.end) - minToY(b.start));
        el.style.top = `${top}px`;
        el.style.height = `${height}px`;

        el.innerHTML = `
          <div class="resizeHandle top" data-handle="top"></div>
          <div class="resizeHandle bottom" data-handle="bottom"></div>
          <div class="t">
            <div class="label" contenteditable="true" spellcheck="false"></div>
            <div class="miniBtnRow">
              <button class="miniBtn del" data-action="del">Delete</button>
            </div>
          </div>
          <div class="time"></div>
        `;

        const labelEl = el.querySelector('.label');
        labelEl.textContent = b.label || '';
        labelEl.title = 'Click to edit';

        const timeEl = el.querySelector('.time');
        timeEl.textContent = `${fmtTime(b.start)}–${fmtTime(b.end)} (${fmtDur(b.end-b.start)})`;

        // Inline edit: update state on blur (and on Enter)
        labelEl.addEventListener('keydown', (ev) => {
          if(ev.key === 'Enter'){
            ev.preventDefault();
            labelEl.blur();
          }
        });
        labelEl.addEventListener('blur', () => {
          const txt = (labelEl.textContent || '').trim();
          updateBlock(kind, b.id, { label: txt });
          // re-render time/height maybe changed by other ops; keep minimal:
          save();
        });

        // Delete
        el.addEventListener('click', (ev) => {
          const btn = ev.target.closest('button');
          if(!btn) return;
          if(btn.dataset.action === 'del'){
            ev.stopPropagation();
            removeBlock(kind, b.id);
          }
        });

        // Drag/resize (disable if editing text)
        el.addEventListener('pointerdown', (ev) => {
          if(ev.target.closest('[contenteditable="true"]')) return; // don't drag while editing
          const handle = ev.target.closest('.resizeHandle');
          if(handle){
            startResize(ev, col, kind, b.id, handle.dataset.handle);
            return;
          }
          if(ev.target.closest('button')) return;
          startMove(ev, col, kind, b.id);
        });

        col.appendChild(el);
      }

      // Drawing blocks on empty space
      function attachDraw(col){
        let drawing = null;

        col.addEventListener('pointerdown', (ev) => {
          if(ev.target.closest('.block')) return;

          col.setPointerCapture(ev.pointerId);
          const kind = col.dataset.kind;
          const rect = col.getBoundingClientRect();
          const y0 = clamp(ev.clientY - rect.top, 0, dayHeight);
          const startMin = snap(yToMin(y0));
          drawing = { kind, startMin, currentMin: startMin };

          const temp = document.createElement('div');
          temp.className = 'block' + (kind === 'actual' ? ' actual' : '');
          temp.style.left = '10px';
          temp.style.right = '10px';
          temp.style.top = `${minToY(startMin)}px`;
          temp.style.height = `${minToY(startMin + snapMin) - minToY(startMin)}px`;
          temp.style.opacity = '0.85';
          temp.style.cursor = 'crosshair';
          temp.innerHTML = `<div class="time">${fmtTime(startMin)}–${fmtTime(startMin)} (drawing)</div>`;
          col.appendChild(temp);
          drawing.temp = temp;

          ev.preventDefault();
        });

        col.addEventListener('pointermove', (ev) => {
          if(!drawing) return;
          const rect = col.getBoundingClientRect();
          const y = clamp(ev.clientY - rect.top, 0, dayHeight);
          const m = snap(yToMin(y));
          drawing.currentMin = m;

          const a = Math.min(drawing.startMin, drawing.currentMin);
          const b = Math.max(drawing.startMin, drawing.currentMin);
          const top = minToY(a);
          const height = Math.max(8, minToY(b) - minToY(a));
          drawing.temp.style.top = `${top}px`;
          drawing.temp.style.height = `${height}px`;
          drawing.temp.querySelector('.time').textContent = `${fmtTime(a)}–${fmtTime(b)} (drawing)`;
        });

        col.addEventListener('pointerup', () => {
          if(!drawing) return;
          const kind = drawing.kind;
          const a = Math.min(drawing.startMin, drawing.currentMin);
          const b = Math.max(drawing.startMin, drawing.currentMin);
          drawing.temp.remove();
          drawing = null;

          const created = createBlock(kind, a, b, '');
          if(!created) return;

          // Focus label for inline edit
          requestAnimationFrame(() => {
            const targetCol = kind === 'plan' ? planCol : actualCol;
            const el = targetCol.querySelector(`.block[data-id="${CSS.escape(created.id)}"]`);
            const labelEl = el && el.querySelector('.label');
            if(labelEl){
              labelEl.focus();
              // move cursor to end
              const range = document.createRange();
              range.selectNodeContents(labelEl);
              range.collapse(false);
              const sel = window.getSelection();
              sel.removeAllRanges();
              sel.addRange(range);
            }
          });
        });
      }

      // FIXED dragging: compute delta minutes from delta pixels directly
      function startMove(ev, col, kind, id){
        const el = col.querySelector(`.block[data-id="${CSS.escape(id)}"]`);
        if(!el) return;

        el.style.cursor = 'grabbing';
        el.setPointerCapture(ev.pointerId);

        const rect = col.getBoundingClientRect();
        const pointerStartY = clamp(ev.clientY - rect.top, 0, dayHeight);

        const b = state[kind].find(x => x.id === id);
        const dur = b.end - b.start;
        const origStart = b.start;

        function onMove(e){
          const y = clamp(e.clientY - rect.top, 0, dayHeight);
          const deltaPx = y - pointerStartY;
          const deltaMin = deltaPx / pxPerMin;          // raw minutes
          let newStart = snap(origStart + deltaMin);    // snap to 5-min
          newStart = clamp(newStart, 0, DAY_MIN - dur);
          b.start = newStart;
          b.end = newStart + dur;

          // update DOM directly for smoothness
          el.style.top = `${minToY(b.start)}px`;
          el.querySelector('.time').textContent = `${fmtTime(b.start)}–${fmtTime(b.end)} (${fmtDur(dur)})`;
        }

        function onUp(){
          el.style.cursor = 'grab';
          window.removeEventListener('pointermove', onMove);
          window.removeEventListener('pointerup', onUp);
          sortKind(kind);
          save();
          render(); // re-sync everything
        }

        window.addEventListener('pointermove', onMove);
        window.addEventListener('pointerup', onUp);
      }

      function startResize(ev, col, kind, id, which){
        const el = col.querySelector(`.block[data-id="${CSS.escape(id)}"]`);
        if(!el) return;
        el.setPointerCapture(ev.pointerId);

        const rect = col.getBoundingClientRect();
        const b = state[kind].find(x => x.id === id);
        const origStart = b.start;
        const origEnd = b.end;

        function onMove(e){
          const y = clamp(e.clientY - rect.top, 0, dayHeight);
          const m = snap(yToMin(y));
          if(which === 'top'){
            const newStart = clamp(m, 0, origEnd - snapMin);
            b.start = newStart;
            b.end = origEnd;
          }else{
            const newEnd = clamp(m, origStart + snapMin, DAY_MIN);
            b.start = origStart;
            b.end = newEnd;
          }
          const dur = b.end - b.start;
          el.style.top = `${minToY(b.start)}px`;
          el.style.height = `${Math.max(8, minToY(b.end) - minToY(b.start))}px`;
          el.querySelector('.time').textContent = `${fmtTime(b.start)}–${fmtTime(b.end)} (${fmtDur(dur)})`;
        }

        function onUp(){
          window.removeEventListener('pointermove', onMove);
          window.removeEventListener('pointerup', onUp);
          updateBlock(kind, id, { start: b.start, end: b.end });
          render();
        }

        window.addEventListener('pointermove', onMove);
        window.addEventListener('pointerup', onUp);
        ev.preventDefault();
      }

      // Buttons
      document.getElementById('print').addEventListener('click', () => window.print());
      document.getElementById('clear').addEventListener('click', () => {
        if(confirm('Clear plan + actual for this date?')){
          state = { plan: [], actual: [] };
          save();
          render();
        }
      });
      document.getElementById('today').addEventListener('click', () => {
        dateInput.value = new Date().toISOString().slice(0,10);
        load();
      });
      dateInput.addEventListener('change', load);

      // Pomodoro simplified: Work/Break only, manual confirmation between phases
      let pomo = {
        phase: 'Idle',          // Idle, Work, Break, Work done, Break done, Paused
        running: false,
        paused: false,
        timer: null,
        endAt: 0,
        startedAt: 0,
        durationMs: 0,
      };

      function cfg(){
        const workMin = clamp(parseInt(workMinEl.value,10) || 25, 1, 240);
        const breakMin = clamp(parseInt(breakMinEl.value,10) || 5, 1, 120);
        return { workMs: workMin * 60 * 1000, breakMs: breakMin * 60 * 1000 };
      }

      function mmss(ms){
        const s = Math.max(0, Math.floor(ms / 1000));
        const m = Math.floor(s / 60);
        const r = s % 60;
        return `${pad2(m)}:${pad2(r)}`;
      }

      function setPomoUI(){
        pomoPhaseEl.textContent = pomo.phase;
        if(!pomo.running){
          pomoLeftEl.textContent = '—';
          return;
        }
        const left = pomo.paused ? (pomo.endAt - pomo.pauseAt) : (pomo.endAt - Date.now());
        pomoLeftEl.textContent = mmss(left);
      }

      function notify(title, body){
        try{
          if(Notification.permission === 'granted'){
            new Notification(title, { body });
          }
        }catch{}
      }
      function requestNotifications(){
        if(!('Notification' in window)){
          alert('Notifications not supported in this browser.');
          return;
        }
        Notification.requestPermission().then(p => {
          if(p === 'granted'){
            notify('Notifications enabled', 'Pomodoro alerts are ready.');
          }else{
            alert('Notification permission not granted.');
          }
        });
      }

      function startPhase(name, ms){
        pomo.phase = name;
        pomo.running = true;
        pomo.paused = false;
        pomo.startedAt = Date.now();
        pomo.durationMs = ms;
        pomo.endAt = Date.now() + ms;
        setPomoUI();
        tickPomo();
        renderPomodoroOverlay();
        notify('Pomodoro', `${name} started (${Math.round(ms/60000)}m).`);
      }

      function stopPomo(){
        pomo.running = false;
        pomo.paused = false;
        pomo.phase = 'Idle';
        pomo.endAt = 0;
        pomo.startedAt = 0;
        pomo.durationMs = 0;
        if(pomo.timer) clearInterval(pomo.timer);
        pomo.timer = null;
        setPomoUI();
        renderPomodoroOverlay();
      }

      function pausePomo(){
        if(!pomo.running || pomo.paused) return;
        pomo.paused = true;
        pomo.pauseAt = Date.now();
        pomo.phase = 'Paused';
        setPomoUI();
        renderPomodoroOverlay();
      }

      function resumeIfPaused(newPhaseLabel){
        if(!pomo.running || !pomo.paused) return false;
        pomo.paused = false;
        const pausedFor = Date.now() - pomo.pauseAt;
        pomo.endAt += pausedFor;
        pomo.phase = newPhaseLabel;
        setPomoUI();
        renderPomodoroOverlay();
        return true;
      }

      function tickPomo(){
        if(pomo.timer) clearInterval(pomo.timer);
        pomo.timer = setInterval(() => {
          if(!pomo.running) return;
          if(pomo.paused){
            setPomoUI();
            return;
          }
          const left = pomo.endAt - Date.now();
          setPomoUI();
          renderPomodoroOverlay();
          if(left <= 0){
            const finished = pomo.phase;
            pomo.running = false;
            if(finished === 'Work'){
              pomo.phase = 'Work done';
              notify('Pomodoro', 'Work ended. Start break when ready.');
            }else if(finished === 'Break'){
              pomo.phase = 'Break done';
              notify('Pomodoro', 'Break ended. Start work when ready.');
            }
            setPomoUI();
            renderPomodoroOverlay();
          }
        }, 250);
      }

      document.getElementById('notify').addEventListener('click', requestNotifications);

      document.getElementById('pomoStartWork').addEventListener('click', () => {
        const { workMs } = cfg();
        if(resumeIfPaused('Work')) return;
        startPhase('Work', workMs);
      });

      document.getElementById('pomoStartBreak').addEventListener('click', () => {
        const { breakMs } = cfg();
        if(resumeIfPaused('Break')) return;
        startPhase('Break', breakMs);
      });

      document.getElementById('pomoPause').addEventListener('click', pausePomo);
      document.getElementById('pomoStop').addEventListener('click', stopPomo);

      // Render active pomodoro on the calendar (plan column) as an overlay block
      let pomoOverlay = null;
      function ensurePomoOverlay(){
        if(pomoOverlay && pomoOverlay.isConnected) return;
        pomoOverlay = document.createElement('div');
        pomoOverlay.className = 'block pomoActive';
        pomoOverlay.innerHTML = `
          <div class="t">
            <div class="label">Pomodoro</div>
          </div>
          <div class="time"></div>
        `;
        planCol.appendChild(pomoOverlay);
      }

      function renderPomodoroOverlay(){
        // Only show for today's date (so "now" makes sense)
        const todayStr = new Date().toISOString().slice(0,10);
        const showDate = (dateInput.value === todayStr);

        if(!pomo.running || pomo.paused || !showDate || (pomo.phase !== 'Work' && pomo.phase !== 'Break')){
          if(pomoOverlay && pomoOverlay.isConnected) pomoOverlay.remove();
          return;
        }

        ensurePomoOverlay();

        const now = Date.now();
        const started = pomo.startedAt || now;
        const endAt = pomo.endAt || now;

        // Compute start/end minutes in day
        const d = new Date();
        const dayNowMin = d.getHours() * 60 + d.getMinutes();
        // Anchor "now" to the overlay duration remaining/elapsed:
        // We'll place start = now - elapsed, end = now + remaining (rounded to snaps)
        const elapsedMs = Math.max(0, now - started);
        const remainingMs = Math.max(0, endAt - now);
        const elapsedMin = Math.round(elapsedMs / 60000);
        const remainingMin = Math.round(remainingMs / 60000);

        let startMin = snap(dayNowMin - elapsedMin);
        let endMin = snap(dayNowMin + remainingMin);

        startMin = clamp(startMin, 0, DAY_MIN);
        endMin = clamp(endMin, 0, DAY_MIN);
        if(endMin - startMin < snapMin) endMin = clamp(startMin + snapMin, 0, DAY_MIN);

        const top = minToY(startMin);
        const height = Math.max(10, minToY(endMin) - minToY(startMin));
        pomoOverlay.style.top = `${top}px`;
        pomoOverlay.style.height = `${height}px`;

        const label = pomoOverlay.querySelector('.label');
        label.textContent = `Pomodoro (${pomo.phase})`;

        const time = pomoOverlay.querySelector('.time');
        time.textContent = `${fmtTime(startMin)}–${fmtTime(endMin)} (live)`;
      }

      // Init date
      dateInput.value = new Date().toISOString().slice(0,10);

      // Hook drawing
      attachDraw(planCol);
      attachDraw(actualCol);

      // Initial render
      buildTimeline();
      load();
      setPomoUI();
      updateNowLine();
      renderPomodoroOverlay();
      setInterval(() => {
        updateNowLine();
        renderPomodoroOverlay();
      }, 30_000);
    })();
  </script>
</body>
</html>
